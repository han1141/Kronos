import pandas as pd
import requests
import time
from backtesting import Backtest, Strategy
from backtesting.lib import crossover
import ta
import numpy as np


def get_full_historical_data(
    symbol: str, interval: str, start_str: str, end_str: str = None
) -> pd.DataFrame:
    base_url = "https://api.binance.com/api/v3/klines"
    limit = 1000
    start_time = int(pd.to_datetime(start_str).timestamp() * 1000)
    end_time = (
        int(pd.to_datetime(end_str).timestamp() * 1000)
        if end_str
        else int(time.time() * 1000)
    )
    all_data = []

    while start_time < end_time:
        params = {
            "symbol": symbol,
            "interval": interval,
            "startTime": start_time,
            "endTime": end_time,
            "limit": limit,
        }
        try:
            response = requests.get(base_url, params=params)
            response.raise_for_status()
            data = response.json()
            if not data:
                break
            all_data.extend(data)
            start_time = data[-1][0] + 1
        except requests.exceptions.RequestException as e:
            print(f"网络错误: {e}, 5秒后重试...")
            time.sleep(5)

    df = pd.DataFrame(
        all_data,
        columns=[
            "timestamp",
            "Open",
            "High",
            "Low",
            "Close",
            "Volume",
            "close_time",
            "quote_asset_volume",
            "number_of_trades",
            "taker_buy_base_asset_volume",
            "taker_buy_quote_asset_volume",
            "ignore",
        ],
    )
    df = df[["timestamp", "Open", "High", "Low", "Close", "Volume"]].copy()

    for col in ["Open", "High", "Low", "Close", "Volume"]:
        df[col] = pd.to_numeric(df[col])

    df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
    df.set_index("timestamp", inplace=True)
    print(f"成功获取 {symbol} 从 {df.index[0]} 到 {df.index[-1]} 的 {len(df)} 条数据。")
    return df


class OptimizedEMATrendStrategy(Strategy):
    ema_fast_period = 12
    ema_slow_period = 26
    ema_long_period = 50
    rsi_period = 14
    rsi_oversold = 30
    rsi_overbought = 70
    atr_period = 14
    atr_sl_multiplier = 2.0
    position_size = 0.95

    def init(self):
        self.ema_fast = self.I(
            lambda: ta.trend.EMAIndicator(
                close=pd.Series(self.data.Close), window=self.ema_fast_period
            ).ema_indicator()
        )

        self.ema_slow = self.I(
            lambda: ta.trend.EMAIndicator(
                close=pd.Series(self.data.Close), window=self.ema_slow_period
            ).ema_indicator()
        )

        self.ema_long = self.I(
            lambda: ta.trend.EMAIndicator(
                close=pd.Series(self.data.Close), window=self.ema_long_period
            ).ema_indicator()
        )

        self.rsi = self.I(
            lambda: ta.momentum.RSIIndicator(
                close=pd.Series(self.data.Close), window=self.rsi_period
            ).rsi()
        )

        self.atr = self.I(
            lambda: ta.volatility.AverageTrueRange(
                high=pd.Series(self.data.High),
                low=pd.Series(self.data.Low),
                close=pd.Series(self.data.Close),
                window=self.atr_period,
            ).average_true_range()
        )

        self.trailing_sl = 0.0

    def next(self):
        price = self.data.Close[-1]
        current_rsi = self.rsi[-1]

        if self.position:
            if self.position.is_long:
                if price <= self.trailing_sl:
                    self.position.close()
                    return
                new_sl = price - self.atr[-1] * self.atr_sl_multiplier
                self.trailing_sl = max(self.trailing_sl, new_sl)

            else:
                if price >= self.trailing_sl:
                    self.position.close()
                    return
                new_sl = price + self.atr[-1] * self.atr_sl_multiplier
                self.trailing_sl = min(self.trailing_sl, new_sl)

        else:
            is_uptrend = (
                price > self.ema_long[-1] and self.ema_fast[-1] > self.ema_slow[-1]
            )
            is_downtrend = (
                price < self.ema_long[-1] and self.ema_fast[-1] < self.ema_slow[-1]
            )

            golden_cross = crossover(self.ema_fast, self.ema_slow)
            death_cross = crossover(self.ema_slow, self.ema_fast)

            if (
                is_uptrend
                and golden_cross
                and current_rsi < self.rsi_overbought
                and current_rsi > self.rsi_oversold
            ):

                size = self.position_size
                initial_sl = price - self.atr[-1] * self.atr_sl_multiplier

                self.buy(size=size, sl=initial_sl)
                self.trailing_sl = initial_sl

            elif (
                is_downtrend
                and death_cross
                and current_rsi > self.rsi_oversold
                and current_rsi < self.rsi_overbought
            ):

                size = self.position_size
                initial_sl = price + self.atr[-1] * self.atr_sl_multiplier

                self.sell(size=size, sl=initial_sl)
                self.trailing_sl = initial_sl


if __name__ == "__main__":
    SYMBOL = "BTCUSDT"
    TIME_INTERVAL = "4h"
    START_DATE = "2018-01-01"
    END_DATE = "2020-09-27"
    INITIAL_CASH = 500_000
    COMMISSION_FEE = 0.001

    print("正在获取历史数据...")
    data = get_full_historical_data(
        symbol=SYMBOL, interval=TIME_INTERVAL, start_str=START_DATE, end_str=END_DATE
    )

    if not data.empty:
        print("\n开始执行【优化版EMA趋势策略】回测...")
        bt = Backtest(
            data,
            OptimizedEMATrendStrategy,
            cash=INITIAL_CASH,
            commission=COMMISSION_FEE,
            exclusive_orders=True,
            trade_on_close=True,
            finalize_trades=True,
        )

        stats = bt.run()
        print("回测完成！")
        print(stats)

        print("\n正在生成回测图表HTML文件...")
        bt.plot(filename="optimized_strategy.html", open_browser=False)
        print("图表已保存: optimized_strategy.html")

    else:
        print("未能获取到数据，回测无法进行。")
